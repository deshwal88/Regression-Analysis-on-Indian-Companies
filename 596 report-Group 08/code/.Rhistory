data <- read.csv("data/indian companies complete data 2025.csv",
stringsAsFactors = FALSE)
data <- read.csv("/data/indian companies complete data 2025.csv",
stringsAsFactors = FALSE)
data <- read.csv("./data/indian companies complete data 2025.csv",
stringsAsFactors = FALSE)
data <- read.csv("../data/indian companies complete data 2025.csv",
stringsAsFactors = FALSE)
data <- data[!duplicated(data$COMPANY.NAME), ]
head(data)
summary(data)
data = read.csv("../data/indian_companies_processed.csv", skipNul = TRUE, row.names=1)
knitr::opts_chunk$set(echo = FALSE)
df <- read.csv("../data/indian_companies_processed.csv", stringsAsFactors = FALSE)
companies <- read.csv("../data/indian_companies_transformed.csv", skipNul = TRUE)
model_data <- read.csv("../data/indian_companies_processed.csv",
stringsAsFactors = FALSE)
data = read.csv("../data/indian_companies_processed.csv", skipNul = TRUE, row.names=1)
head(data)
lmod = lm(PACKAGE ~ ., data = data)
summary(lmod)
n = nrow(data)
p = length(coef(lmod))
plot(lmod, 1)
library(MASS)
bc = boxcox(lmod, lambda = seq(-2, 2, 0.1))
bc
lambda_opt = bc$x[which.max(bc$y)]
lambda_opt
data$logPACKAGE = log(data$PACKAGE)
lmod_log = lm(logPACKAGE ~ ., data = data)
summary(lmod_log)
plot(lmod_log, 1)
resi = residuals(lmod)
qqnorm(resi)
qqline(resi)
library(car)
avPlots(lm(PACKAGE ~ YEARS.OLD + TOTAL_EMPLOYEES + BRANCHES + RATING + REVIEWS,
data = data), ask = FALSE)
hval = hatvalues(lmod)
#which(hval > 2 * p/n)
jackres = rstudent(lmod)
crival <- abs(qt(0.1/2/n, n - 1 - p))
crival
idy = which(abs(jackres) > crival)
idy
library("faraway")
cook = cooks.distance(lmod)
halfnorm(cook, 1, labs = rownames(data), ylab = "Cook's distance")
idx <- which(cook > 1)
idx
keep = intersect(idy, idx)
remove = setdiff(idy, idx)
clean_data = data[-remove,]
lmod2 = lm(PACKAGE ~ ., data = clean_data)
#round(summary(lmod2)$coef, 3)
summary(lmod2)
plot(lmod_log$residuals, model.matrix(lmod_log)["REVIEWS"])
plot(lmod_log$residuals, model.matrix(lmod_log)[,"REVIEWS"])
plot(y=lmod_log$residuals, x = model.matrix(lmod_log)[,"REVIEWS"])
plot(y=lmod_log$residuals, x = model.matrix(lmod_log)[,"RATING"])
plot(y=lmod_log$residuals, x = model.matrix(lmod_log)[,"BRANCHES"])
clean_data$logPACKAGE2 = log(clean_data$PACKAGE)
clean_data$logREVIEWS = log(clean_data$REVIEWS)
clean_data$logRATING = log(clean_data$RATING)
clean_data$logBRANCHES = log(clean_data$BRANCHES)
lmod_log2 = lm(logPACKAGE2 ~ YEARS.OLD + INDUSTRY + INDIA.HQ + TOTAL_EMPLOYEES + logBRANCHES + logRATING + logREVIEWS, data = clean_data)
summary(lmod_log2)
plot(y=lmod_log$residuals, x = model.matrix(lmod2)[,"logBRANCHES"])
plot(y=lmod2$residuals, x = model.matrix(lmod2)[,"logBRANCHES"])
plot(y=lmod_log2$residuals, x = model.matrix(lmod_log2)[,"logBRANCHES"])
library("faraway")
cook = cooks.distance(lmod_log2)
halfnorm(cook, 1, labs = rownames(data), ylab = "Cook's distance")
idx <- which(cook > 1)
idx
idx <- which(cook > 0.5)
idx
halfnorm(cook, 1, labs = rownames(data), ylab = "Cook's distance")
summary(lmod_log2)
